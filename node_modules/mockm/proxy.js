"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));

var _flat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/flat"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/reduce"));

const util = require(`./util/index.js`);

const {
  print
} = require(`./util/log.js`);

async function serverProxy({
  allRoute
}) {
  var _context3, _context4, _context5, _context6;

  const config = global.config;
  const {
    tool,
    business
  } = util;
  const {
    getProxyConfig,
    middleware,
    reqHandle,
    clientInjection,
    historyHandle,
    saveLog
  } = business;
  const {
    allowCors
  } = clientInjection();
  const {
    setHttpHistoryWrap,
    ignoreHttpHistory
  } = historyHandle();
  const {
    middlewares,
    middlewaresObj
  } = middleware.getJsonServerMiddlewares();

  const proxy = require(`http-proxy-middleware`).createProxyMiddleware;

  const {
    server: {
      app
    }
  } = require(`./util/index.js`);

  const {
    httpServer,
    onlyHttpServer
  } = business.getHttpServer({
    app,
    name: `port`
  }); // 当传入 server 之后, app 的 listen 方法被重写为 server 的 listen 方法

  onlyHttpServer && require(`@wll8/express-ws`)({
    app,
    server: onlyHttpServer
  });

  require(`@wll8/express-ws`)({
    app,
    server: httpServer
  });

  await business.pluginRun(`useCreated`, app); // 此中间件比任何用户自定义的都要先运行

  app.use((req, res, next) => {
    // 创建一个对象用于挂载用户添加的方法
    res.mm = {
      resHandleJsonApi: arg => arg.resHandleJsonApi(arg)
    };
    next();
  });
  middleware.reWriteRouter({
    app: app,
    routes: config.route
  });
  app.use( // middlewaresObj.compression,
  // middlewaresObj.corsMiddleware,
  // middlewaresObj.serveStatic,
  config._bodyParserMid, middlewaresObj.urlencodedParser, middlewaresObj.logger); // 添加中间件, 方便取值

  await business.pluginRun(`useParserCreated`, app);
  app.use((req, res, next) => {
    // 修改分页参数, 符合项目中的参数
    req.query.page && (req.query._page = req.query.page);
    req.query.pageSize && (req.query._limit = req.query.pageSize);
    next();
  });
  app.use((req, res, next) => {
    // 保存自定义接口的请求历史
    const apiCount = tool.file.fileStore(global.config._store).updateApiCount();
    const apiId = tool.hex.string10to62(apiCount);
    req.apiId = apiId; // 只拷贝必要的字段，避免深拷贝整个req对象

    const newReq = {
      method: req.method,
      url: req.url,
      originalUrl: req.originalUrl,
      headers: { ...req.headers
      },
      // 浅拷贝headers
      body: req.body ? JSON.parse((0, _stringify.default)(req.body)) : undefined,
      // 只深拷贝body
      query: { ...req.query
      },
      // 浅拷贝query
      params: { ...req.params
      },
      // 浅拷贝params
      apiId: apiId
    };
    const oldSend = res.send;

    res.send = (data = ``) => {
      var _context, _context2;

      let buffer = undefined;
      const dataType = tool.type.isType(data);

      if ((0, _includes.default)(_context = [`object`, `array`]).call(_context, dataType)) {
        buffer = Buffer.from(tool.obj.o2s(data));
      }

      if ((0, _includes.default)(_context2 = [`string`]).call(_context2, dataType)) {
        buffer = Buffer.from(data);
      }

      res.send = oldSend;
      setHttpHistoryWrap({
        req: newReq,
        res,
        mock: true,
        buffer
      });
      return res.send(data);
    };

    next();
  });
  app.use((req, res, next) => {
    // 注入上次请求
    reqHandle().injectionReq({
      req,
      res,
      type: `get`
    });
    next();
  });
  let list = (0, _flat.default)(_context3 = (0, _reduce.default)(_context4 = [`api`, `db`, `resetUrl`, `static`, `apiWeb`]).call(_context4, (acc, cur) => {
    acc.push(allRoute.obj[cur]);
    return acc;
  }, [])).call(_context3);

  for (let index = 0; index < list.length; index++) {
    const item = list[index];
    app.use(item.route, (req, res, next) => {
      allowCors({
        req,
        res,
        next
      });
    });

    if (Boolean(item.disable) === false) {
      const handleErr = async (...arg) => {
        const [req, res, next] = arg;

        try {
          return await item.action(...arg);
        } catch (error) {
          print(tool.cli.colors.red(`api error: ${item.method} ${item.route}`));
          print(error);

          if (item.method !== `ws`) {
            res.status(500).json({
              msg: String(error)
            });
          }
        }
      };

      const action = typeof item.action === `function` ? handleErr : item.action;
      app[item.method](item.route, action);
    }
  }

  list = (0, _flat.default)(_context5 = (0, _reduce.default)(_context6 = [`proxy`]).call(_context6, (acc, cur) => {
    acc.push(allRoute.obj[cur]);
    return acc;
  }, [])).call(_context5);

  for (let index = 0; index < list.length; index++) {
    const item = list[index];

    if (config.hostMode === false) {
      item.info.mid && app.use(item.route, item.info.mid);
      app.use(item.route, proxy(item.route, getProxyConfig(item.info)));
    }
  }

  app.use((error, req, res, next) => {
    saveLog({
      logStr: error.stack,
      logPath: config._errLog
    });
    next(error);
  });
}

module.exports = serverProxy;